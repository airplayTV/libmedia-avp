{"version":3,"file":"src_avformat_bsf_aac_ADTS2RawFilter_ts-src_avformat_formats_IFormat_ts-src_avformat_formats_m-a4eebf.avplayer.js","mappings":"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","sources":["webpack://AVPlayer/./src/avformat/bsf/aac/ADTS2RawFilter.ts","webpack://AVPlayer/./src/avformat/formats/IFormat.ts","webpack://AVPlayer/./src/avformat/formats/mpegts/function/parsePES.ts","webpack://AVPlayer/./src/avformat/formats/mpegts/struct.ts","webpack://AVPlayer/./src/avformat/function/getBytesByDuration.ts","webpack://AVPlayer/./src/avformat/function/seekInBytes.ts","webpack://AVPlayer/./src/avutil/codecs/dts.ts","webpack://AVPlayer/./src/avutil/codecs/opus.ts"],"sourcesContent":["/*\r\n * libmedia ADTS2RawFilter\r\n *\r\n * 版权所有 (C) 2024 赵高兴\r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n * 此文件是 libmedia 的一部分\r\n * This file is part of libmedia.\r\n * \r\n * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1\r\n * 或任何其更新的版本条款重新分发或修改它\r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证\r\n * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。\r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport AVPacket, { AVPacketFlags } from 'avutil/struct/avpacket'\r\nimport AVBSFilter from '../AVBSFilter'\r\nimport { mapUint8Array, memcpyFromUint8Array } from 'cheap/std/memory'\r\nimport * as logger from 'common/util/logger'\r\nimport * as errorType from 'avutil/error'\r\nimport { AV_TIME_BASE, AV_TIME_BASE_Q, NOPTS_VALUE, NOPTS_VALUE_BIGINT } from 'avutil/constant'\r\nimport { avCodecParameters2Extradata } from 'avutil/codecs/aac'\r\nimport { avRescaleQ } from 'avutil/util/rational'\r\nimport { avFree, avMalloc } from 'avutil/util/mem'\r\nimport AVCodecParameters from 'avutil/struct/avcodecparameters'\r\nimport { Rational } from 'avutil/struct/rational'\r\nimport { addAVPacketData, addAVPacketSideData, unrefAVPacket } from 'avutil/util/avpacket'\r\nimport { AVPacketSideDataType } from 'avutil/codec'\r\nimport * as aac from 'avutil/codecs/aac'\r\nimport * as is from 'common/util/is'\r\nimport concatTypeArray from 'common/function/concatTypeArray'\r\n\r\ninterface CacheItem {\r\n  duration: number\r\n  dts: bigint\r\n  buffer: Uint8Array\r\n  extradata: Uint8Array\r\n  pos: int64\r\n}\r\n\r\ninterface PendingItem extends CacheItem {\r\n  miss: number\r\n}\r\n\r\nexport default class ADTS2RawFilter extends AVBSFilter {\r\n\r\n  private streamMuxConfig: {\r\n    profile: number\r\n    sampleRate: number\r\n    channels: number\r\n  }\r\n\r\n  private caches: CacheItem[]\r\n  private pendingItem: PendingItem\r\n\r\n  public init(codecpar: pointer<AVCodecParameters>, timeBase: pointer<Rational>): number {\r\n    super.init(codecpar, timeBase)\r\n\r\n    this.caches = []\r\n    this.streamMuxConfig = {\r\n      profile: NOPTS_VALUE,\r\n      sampleRate: NOPTS_VALUE,\r\n      channels: NOPTS_VALUE\r\n    }\r\n\r\n    return 0\r\n  }\r\n\r\n  public sendAVPacket(avpacket: pointer<AVPacket>): number {\r\n    let i = 0\r\n\r\n    let lastDts = avpacket.dts !== NOPTS_VALUE_BIGINT ? avpacket.dts : avpacket.pts\r\n    let buffer = mapUint8Array(avpacket.data, reinterpret_cast<size>(avpacket.size)).slice()\r\n\r\n    if (this.pendingItem) {\r\n      this.pendingItem.buffer = concatTypeArray(Uint8Array, [this.pendingItem.buffer, buffer.subarray(0, this.pendingItem.miss)])\r\n      buffer = buffer.subarray(this.pendingItem.miss)\r\n      this.caches.push(this.pendingItem)\r\n      this.pendingItem = null\r\n    }\r\n\r\n    while (i < buffer.length) {\r\n\r\n      const info = aac.parseADTSHeader(buffer.subarray(i))\r\n\r\n      if (is.number(info)) {\r\n        let j = i + 1\r\n        for (; j < buffer.length - 1; j++) {\r\n          const syncWord = (buffer[j] << 4) | (buffer[j + 1] >> 4)\r\n          if (syncWord === 0xfff) {\r\n            i = j\r\n            break\r\n          }\r\n        }\r\n        if (j < buffer.length - 1) {\r\n          continue\r\n        }\r\n        logger.error('AACADTSParser parse failed')\r\n        return errorType.DATA_INVALID\r\n      }\r\n\r\n      const item: CacheItem = {\r\n        dts: lastDts,\r\n        buffer: null,\r\n        extradata: null,\r\n        duration: NOPTS_VALUE,\r\n        pos: avpacket.pos\r\n      }\r\n\r\n      item.buffer = buffer.subarray(i + info.headerLength, i + info.headerLength + info.framePayloadLength)\r\n\r\n      this.streamMuxConfig.profile = info.profile\r\n      this.streamMuxConfig.sampleRate = info.sampleRate\r\n      this.streamMuxConfig.channels = info.channels\r\n\r\n      const hasNewExtraData = this.inCodecpar.profile !== this.streamMuxConfig.profile\r\n        || this.inCodecpar.sampleRate !== this.streamMuxConfig.sampleRate\r\n        || this.inCodecpar.chLayout.nbChannels !== this.streamMuxConfig.channels\r\n\r\n\r\n      const duration = avRescaleQ(\r\n        static_cast<int64>((info.numberOfRawDataBlocksInFrame + 1) * 1024 / this.streamMuxConfig.sampleRate * AV_TIME_BASE),\r\n        AV_TIME_BASE_Q,\r\n        this.inTimeBase\r\n      )\r\n\r\n      item.duration = Number(duration)\r\n\r\n      if (hasNewExtraData) {\r\n        this.inCodecpar.profile = this.streamMuxConfig.profile\r\n        this.inCodecpar.sampleRate = this.streamMuxConfig.sampleRate\r\n        this.inCodecpar.chLayout.nbChannels = this.streamMuxConfig.channels\r\n\r\n        const extradata = avCodecParameters2Extradata(accessof(this.inCodecpar))\r\n\r\n        if (this.inCodecpar.extradata) {\r\n          avFree(this.inCodecpar.extradata)\r\n        }\r\n        this.inCodecpar.extradata = avMalloc(extradata.length)\r\n        memcpyFromUint8Array(this.inCodecpar.extradata, extradata.length, extradata)\r\n        this.inCodecpar.extradataSize = extradata.length\r\n        item.extradata = extradata\r\n      }\r\n\r\n      if (item.buffer.length < info.framePayloadLength) {\r\n        this.pendingItem = {\r\n          ...item,\r\n          miss: info.framePayloadLength - item.buffer.length\r\n        }\r\n      }\r\n      else {\r\n        this.caches.push(item)\r\n      }\r\n\r\n      i += info.aacFrameLength\r\n      lastDts += duration\r\n    }\r\n    return 0\r\n  }\r\n\r\n  public receiveAVPacket(avpacket: pointer<AVPacket>): number {\r\n    if (this.caches.length) {\r\n\r\n      unrefAVPacket(avpacket)\r\n\r\n      const item = this.caches.shift()!\r\n\r\n      const data: pointer<uint8> = avMalloc(item.buffer.length)\r\n      memcpyFromUint8Array(data, item.buffer.length, item.buffer)\r\n      addAVPacketData(avpacket, data, item.buffer.length)\r\n\r\n      avpacket.dts = avpacket.pts = item.dts\r\n      avpacket.pos = item.pos\r\n      avpacket.duration = static_cast<int64>(item.duration)\r\n      avpacket.flags |= AVPacketFlags.AV_PKT_FLAG_KEY\r\n      if (item.extradata) {\r\n        const extradata = avMalloc(item.extradata.length)\r\n        memcpyFromUint8Array(extradata, item.extradata.length, item.extradata)\r\n        addAVPacketSideData(avpacket, AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA, extradata, item.extradata.length)\r\n      }\r\n      return 0\r\n    }\r\n    else {\r\n      return errorType.EOF\r\n    }\r\n  }\r\n\r\n  public reset(): number {\r\n    this.pendingItem = null\r\n    this.caches.length = 0\r\n    return 0\r\n  }\r\n}\r\n","/*\r\n * libmedia abstract format decoder\r\n *\r\n * 版权所有 (C) 2024 赵高兴\r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n * 此文件是 libmedia 的一部分\r\n * This file is part of libmedia.\r\n * \r\n * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1\r\n * 或任何其更新的版本条款重新分发或修改它\r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证\r\n * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。\r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport Stream from 'avutil/AVStream'\r\nimport { AVIFormatContext } from '../AVFormatContext'\r\nimport AVPacket from 'avutil/struct/avpacket'\r\nimport { AVFormat } from 'avutil/avformat'\r\n\r\nexport default abstract class IFormat {\r\n\r\n  public type: AVFormat = AVFormat.UNKNOWN\r\n\r\n  public onStreamAdd: (stream: Stream) => void\r\n\r\n  public abstract init(formatContext: AVIFormatContext): void\r\n\r\n  public async destroy(formatContext: AVIFormatContext): Promise<void> {}\r\n\r\n  public abstract getAnalyzeStreamsCount(): number\r\n  public abstract readHeader(formatContext: AVIFormatContext): Promise<number>\r\n  public abstract readAVPacket(formatContext: AVIFormatContext, avpacket: pointer<AVPacket>): Promise<number>\r\n\r\n  /**\r\n   * seek\r\n   * \r\n   * @param context \r\n   * @param stream \r\n   * @param timestamp 毫秒时间戳\r\n   * @param flags \r\n   * \r\n   * @returns 返回 seek 之前的下一个 avpacket pos（若不知道返回 0n 方便之后可以再 seek 回来）返回负数表示 seek 失败\r\n   */\r\n  public abstract seek(\r\n    formatContext: AVIFormatContext,\r\n    stream: Stream,\r\n    timestamp: int64,\r\n    flags: int32\r\n  ): Promise<int64>\r\n}\r\n","/*\r\n * libmedia parse PES\r\n *\r\n * 版权所有 (C) 2024 赵高兴\r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n * 此文件是 libmedia 的一部分\r\n * This file is part of libmedia.\r\n * \r\n * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1\r\n * 或任何其更新的版本条款重新分发或修改它\r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证\r\n * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。\r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport { PES } from '../struct'\r\nimport { NOPTS_VALUE_BIGINT } from 'avutil/constant'\r\nimport * as logger from 'common/util/logger'\r\nimport { TSStreamId, TSStreamType } from '../mpegts'\r\nimport * as errorType from 'avutil/error'\r\nimport { AVPacketFlags } from 'avutil/struct/avpacket'\r\n\r\nexport default function parsePES(pes: PES) {\r\n\r\n  const data = pes.data\r\n  const streamId = data[3]\r\n  const pesPacketLength = (data[4] << 8) | data[5]\r\n\r\n  let headerSize = 0\r\n  let offset = 0\r\n  let flags = 0\r\n\r\n  if (streamId !== TSStreamId.PROGRAM_STREAM_MAP\r\n    && streamId !== TSStreamId.PADDING_STREAM\r\n    && streamId !== TSStreamId.PRIVATE_STREAM_2\r\n    && streamId !== TSStreamId.ECM_STREAM\r\n    && streamId !== TSStreamId.EMM_STREAM\r\n    && streamId !== TSStreamId.PROGRAM_STREAM_DIRECTORY\r\n    && streamId !== TSStreamId.DSMCC_STREAM\r\n    && streamId !== TSStreamId.TYPE_E_STREAM\r\n  ) {\r\n\r\n    let pts: int64 = NOPTS_VALUE_BIGINT\r\n    let dts: int64 = NOPTS_VALUE_BIGINT\r\n\r\n    while (true) {\r\n      if (6 + offset >= data.length) {\r\n        return errorType.DATA_INVALID\r\n      }\r\n      flags = data[6 + offset]\r\n      if (flags !== 0xff) {\r\n        break\r\n      }\r\n      offset++\r\n    }\r\n\r\n    if ((flags & 0xc0) === 0x40) {\r\n      offset += 2\r\n      flags = data[6 + offset]\r\n    }\r\n    if ((flags & 0xe0) == 0x20) {\r\n\r\n      headerSize += 5\r\n\r\n      pts = pts = static_cast<int64>((data[6 + offset] & 0x0E) * 536870912\r\n        + (data[7 + offset] & 0xFF) * 4194304\r\n        + (data[8 + offset] & 0xFE) * 16384\r\n        + (data[9 + offset] & 0xFF) * 128\r\n        + (data[10 + offset] & 0xFE) / 2)\r\n\r\n      if (flags & 0x10) {\r\n        dts = static_cast<int64>((data[11 + offset] & 0x0E) * 536870912\r\n          + (data[12 + offset] & 0xFF) * 4194304\r\n          + (data[13 + offset] & 0xFE) * 16384\r\n          + (data[14 + offset] & 0xFF) * 128\r\n          + (data[15 + offset] & 0xFE) / 2)\r\n\r\n        headerSize += 5\r\n      }\r\n      else {\r\n        dts = pts\r\n      }\r\n    }\r\n    else if ((flags & 0xc0) == 0x80) {\r\n      // const pesScramblingControl = (data[6] & 0x30) >>> 4\r\n      const ptsDtsFlags = (data[7 + offset] & 0xC0) >>> 6\r\n      headerSize = 3 + data[8 + offset]\r\n\r\n      if (ptsDtsFlags === 0x02 || ptsDtsFlags === 0x03) {\r\n        pts = static_cast<int64>((data[9 + offset] & 0x0E) * 536870912\r\n          + (data[10 + offset] & 0xFF) * 4194304\r\n          + (data[11 + offset] & 0xFE) * 16384\r\n          + (data[12 + offset] & 0xFF) * 128\r\n          + (data[13 + offset] & 0xFE) / 2)\r\n\r\n        if (ptsDtsFlags === 0x03) {\r\n          dts = static_cast<int64>((data[14 + offset] & 0x0E) * 536870912\r\n            + (data[15 + offset] & 0xFF) * 4194304\r\n            + (data[16 + offset] & 0xFE) * 16384\r\n            + (data[17 + offset] & 0xFF) * 128\r\n            + (data[18 + offset] & 0xFE) / 2)\r\n        }\r\n        else {\r\n          dts = pts\r\n        }\r\n      }\r\n    }\r\n    else if (flags === 0xf) {\r\n      headerSize = 1\r\n    }\r\n    else {\r\n      logger.error('invalid data')\r\n      return errorType.DATA_INVALID\r\n    }\r\n\r\n    pes.dts = dts\r\n    pes.pts = pts\r\n\r\n    const payloadStartIndex = 6 + offset + headerSize\r\n    let payloadLength: number = 0\r\n\r\n    if (pesPacketLength !== 0) {\r\n      if (pesPacketLength < offset + headerSize) {\r\n        logger.error('Malformed PES: PES_packet_length < 3 + PES_header_data_length')\r\n        return errorType.DATA_INVALID\r\n      }\r\n      payloadLength = pesPacketLength - (offset + headerSize)\r\n      if (payloadStartIndex + (data.byteLength - payloadStartIndex) != pesPacketLength + 6) {\r\n        logger.warn('PES packet size mismatch')\r\n        pes.flags |= AVPacketFlags.AV_PKT_FLAG_CORRUPT\r\n      }\r\n    }\r\n    else {\r\n      // PES_packet_length === 0\r\n      payloadLength = data.byteLength - payloadStartIndex\r\n    }\r\n\r\n    pes.payload = data.subarray(payloadStartIndex, payloadStartIndex + payloadLength)\r\n  }\r\n  else if (streamId === TSStreamId.PROGRAM_STREAM_MAP\r\n    || streamId === TSStreamId.PRIVATE_STREAM_2\r\n    || streamId === TSStreamId.ECM_STREAM\r\n    || streamId === TSStreamId.EMM_STREAM\r\n    || streamId === TSStreamId.PROGRAM_STREAM_DIRECTORY\r\n    || streamId === TSStreamId.DSMCC_STREAM\r\n    || streamId === TSStreamId.TYPE_E_STREAM\r\n  ) {\r\n    if (pes.streamId === TSStreamType.PRIVATE_DATA) {\r\n      const payloadStartIndex = 6\r\n      let payloadLength: number = 0\r\n\r\n      if (pesPacketLength !== 0) {\r\n        payloadLength = pesPacketLength\r\n      }\r\n      else {\r\n        // PES_packet_length === 0\r\n        payloadLength = data.byteLength - payloadStartIndex\r\n      }\r\n      pes.payload = data.subarray(payloadStartIndex, payloadStartIndex + payloadLength)\r\n    }\r\n  }\r\n  return 0\r\n}\r\n","/*\r\n * libmedia mpegts struct defined\r\n *\r\n * 版权所有 (C) 2024 赵高兴\r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n * 此文件是 libmedia 的一部分\r\n * This file is part of libmedia.\r\n * \r\n * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1\r\n * 或任何其更新的版本条款重新分发或修改它\r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证\r\n * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。\r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport { NOPTS_VALUE, NOPTS_VALUE_BIGINT } from 'avutil/constant'\r\nimport { TSStreamType } from './mpegts'\r\nimport { PID } from './type'\r\n\r\nexport class TSPacketAdaptationFieldInfo {\r\n  discontinuityIndicator: number = 0\r\n  randomAccessIndicator: number = 0\r\n  elementaryStreamPriorityIndicator: number = 0\r\n  pcrFlag: number = 0\r\n  opcrFlag: number = 0\r\n  splicingPointFlag: number = 0\r\n  transportPrivateDataFlag: number = 0\r\n  adaptationFieldExtensionFlag: number = 0\r\n  pcr: bigint = 0n\r\n  opcr: bigint = 0n\r\n  spliceCountDown: number = 0\r\n  transportPrivateData: Uint8Array = null\r\n  extension: Uint8Array = null\r\n}\r\n\r\nexport class TSPacket {\r\n  pos: bigint = NOPTS_VALUE_BIGINT\r\n  payloadUnitStartIndicator: number = 0\r\n  transportPriority: number = 0\r\n  pid: PID = NOPTS_VALUE\r\n  adaptationFieldControl: number = 0\r\n  continuityCounter: number = 0\r\n  transportScramblingControl: number = 0\r\n  adaptationFieldInfo: TSPacketAdaptationFieldInfo = new TSPacketAdaptationFieldInfo()\r\n  payload: Uint8Array = null\r\n}\r\n\r\nexport class TSSliceQueue {\r\n  slices: Uint8Array[] = []\r\n  totalLength: number = 0\r\n  expectedLength: number = NOPTS_VALUE\r\n  randomAccessIndicator: number = 0\r\n  pid: PID = NOPTS_VALUE\r\n  streamType: TSStreamType = TSStreamType.NONE\r\n  pos: bigint = NOPTS_VALUE_BIGINT\r\n}\r\n\r\nexport class PAT {\r\n  versionNumber: number = 0\r\n  networkPid: PID = NOPTS_VALUE\r\n  program2PmtPid: Map<number, PID> = new Map()\r\n}\r\n\r\nexport class SectionPacket extends TSPacket {\r\n}\r\n\r\nexport class ESDescriptor {\r\n  tag: number\r\n  buffer: Uint8Array\r\n}\r\n\r\nexport class PMT {\r\n  versionNumber: number = 0\r\n  programNumber: number = 0\r\n  pcrPid: PID = 0\r\n  pid2StreamType: Map<number, TSStreamType> = new Map()\r\n  pid2ESDescriptor: Map<number, ESDescriptor[]> = new Map()\r\n}\r\n\r\nexport class PES {\r\n  pid: PID = NOPTS_VALUE\r\n  streamType: TSStreamType = TSStreamType.NONE\r\n  streamId: number = NOPTS_VALUE\r\n  dts: bigint = NOPTS_VALUE_BIGINT\r\n  pts: bigint = NOPTS_VALUE_BIGINT\r\n  pos: bigint = NOPTS_VALUE_BIGINT\r\n  payload: Uint8Array = null\r\n  data: Uint8Array = null\r\n  randomAccessIndicator: number = 0\r\n  flags: 0\r\n}\r\n","/*\r\n * libmedia get bytes by duration\r\n *\r\n * 版权所有 (C) 2024 赵高兴\r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n * 此文件是 libmedia 的一部分\r\n * This file is part of libmedia.\r\n * \r\n * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1\r\n * 或任何其更新的版本条款重新分发或修改它\r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证\r\n * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。\r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport { Rational } from 'avutil/struct/rational'\r\nimport AVStream from 'avutil/AVStream'\r\nimport * as array from 'common/util/array'\r\nimport { avRescaleQ } from 'avutil/util/rational'\r\nimport { AV_MILLI_TIME_BASE_Q } from 'avutil/constant'\r\n\r\nexport function getBytesByDuration(streams: AVStream[], duration: int64, timeBase: Rational) {\r\n  let bytes = 0n\r\n  array.each(streams, (st) => {\r\n    bytes += st.codecpar.bitrate * avRescaleQ(duration, timeBase, AV_MILLI_TIME_BASE_Q) / 8000n\r\n  })\r\n  return bytes\r\n}\r\n","/*\r\n * libmedia seek in bytes with timestamp\r\n *\r\n * 版权所有 (C) 2024 赵高兴\r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n * 此文件是 libmedia 的一部分\r\n * This file is part of libmedia.\r\n * \r\n * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1\r\n * 或任何其更新的版本条款重新分发或修改它\r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证\r\n * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。\r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport { AVIFormatContext } from '../AVFormatContext'\r\nimport AVStream from 'avutil/AVStream'\r\nimport { AV_MILLI_TIME_BASE_Q, NOPTS_VALUE_BIGINT } from 'avutil/constant'\r\nimport { avRescaleQ, avRescaleQ2 } from 'avutil/util/rational'\r\nimport { getBytesByDuration } from './getBytesByDuration'\r\nimport { createAVPacket, destroyAVPacket, unrefAVPacket } from 'avutil/util/avpacket'\r\nimport * as errorType from 'avutil/error'\r\nimport AVPacket, { AVPacketFlags } from 'avutil/struct/avpacket'\r\nimport * as logger from 'common/util/logger'\r\nimport { IOFlags } from 'avutil/avformat'\r\nimport { IOError } from 'common/io/error'\r\n\r\nexport default async function seekInBytes(\r\n  context: AVIFormatContext,\r\n  stream: AVStream,\r\n  timestamp: int64,\r\n  firstPacketPos: int64,\r\n  readAVPacket: (context: AVIFormatContext, avpacket: pointer<AVPacket>) => Promise<int32>,\r\n  syncAVPacket: (context: AVIFormatContext) => Promise<void>\r\n) {\r\n\r\n  const now = context.ioReader.getPos()\r\n\r\n  const fileSize = await context.ioReader.fileSize()\r\n  let pos: int64 = NOPTS_VALUE_BIGINT\r\n  let duration = timestamp\r\n  if (stream.startTime !== NOPTS_VALUE_BIGINT) {\r\n    duration -= stream.startTime\r\n  }\r\n  else {\r\n    duration -= stream.firstDTS\r\n  }\r\n\r\n  const pointPts = avRescaleQ(timestamp, stream.timeBase, AV_MILLI_TIME_BASE_Q)\r\n\r\n  // 头十秒直接回到开始位置\r\n  if (pointPts < 10000n) {\r\n    logger.debug(`seek pts is earlier then 10s, seek to first packet pos(${firstPacketPos}) directly`)\r\n    await context.ioReader.seek(firstPacketPos)\r\n    return now\r\n  }\r\n\r\n  let bytes = getBytesByDuration(context.streams, duration, stream.timeBase)\r\n  // 最大到结尾往前 10 秒\r\n  const max = fileSize - getBytesByDuration(context.streams, 10000n, AV_MILLI_TIME_BASE_Q)\r\n  const length = getBytesByDuration(context.streams, 10000n, AV_MILLI_TIME_BASE_Q)\r\n  if (bytes > max) {\r\n    bytes = max\r\n  }\r\n  if (bytes < firstPacketPos) {\r\n    await context.ioReader.seek(firstPacketPos)\r\n    return now\r\n  }\r\n  const avpacket = createAVPacket()\r\n  let seekMax = fileSize\r\n  let seekMin = 0n\r\n\r\n  failed: while (true) {\r\n    if (seekMax - seekMin < length) {\r\n      bytes = seekMin\r\n    }\r\n    await context.ioReader.seek(bytes)\r\n    await syncAVPacket(context)\r\n    if (context.ioReader.flags & IOFlags.ABORT) {\r\n      break\r\n    }\r\n\r\n    let ret = await readAVPacket(context, avpacket)\r\n    let now = avpacket.pos\r\n\r\n    if (ret >= 0) {\r\n      const currentPts = avRescaleQ2(avpacket.pts, addressof(avpacket.timeBase), AV_MILLI_TIME_BASE_Q)\r\n      let diff = currentPts - pointPts\r\n\r\n      logger.debug(`try to seek to pos: ${bytes}, got packet pts: ${avpacket.pts}(${currentPts}ms), diff: ${diff}ms`)\r\n\r\n      // seek 时间戳的前面 10 秒内\r\n      if (diff <= 0n && -diff < 10000n || seekMax - seekMin < length) {\r\n        // 查找最近的关键帧\r\n        const keyPos: int64[] = [now]\r\n        while (diff <= 0) {\r\n          if (avpacket.streamIndex === stream.index && (avpacket.flags & AVPacketFlags.AV_PKT_FLAG_KEY)) {\r\n            keyPos.push(now)\r\n          }\r\n          unrefAVPacket(avpacket)\r\n          ret = await readAVPacket(context, avpacket)\r\n          if (ret < 0) {\r\n            if (ret === IOError.END) {\r\n              break\r\n            }\r\n            else if (ret === IOError.AGAIN) {\r\n              continue\r\n            }\r\n            // 失败了重新 seek 回原来的位置\r\n            else {\r\n              pos = NOPTS_VALUE_BIGINT\r\n              break failed\r\n            }\r\n          }\r\n          now = avpacket.pos\r\n          diff = avRescaleQ2(avpacket.pts, addressof(avpacket.timeBase), AV_MILLI_TIME_BASE_Q) - pointPts\r\n        }\r\n        pos = keyPos.pop()\r\n        break\r\n      }\r\n      // seek 后面\r\n      else if (diff > 0n) {\r\n        seekMax = bytes\r\n        bytes = (seekMin + seekMax) >> 1n\r\n      }\r\n      // seek 前面 10 秒外\r\n      else {\r\n        seekMin = bytes\r\n        bytes = (seekMin + seekMax) >> 1n\r\n      }\r\n    }\r\n    else {\r\n      // 失败了重新 seek 回原来的位置\r\n      pos = NOPTS_VALUE_BIGINT\r\n      break\r\n    }\r\n    if (context.ioReader.flags & IOFlags.ABORT) {\r\n      break\r\n    }\r\n  }\r\n\r\n  destroyAVPacket(avpacket)\r\n\r\n  if (pos !== NOPTS_VALUE_BIGINT) {\r\n    logger.debug(`finally seek to pos ${pos}`)\r\n\r\n    await context.ioReader.seek(pos)\r\n    await syncAVPacket(context)\r\n    return now\r\n  }\r\n  else {\r\n    await context.ioReader.seek(now)\r\n    if (context.ioReader.flags & IOFlags.ABORT) {\r\n      return static_cast<int64>(errorType.EOF)\r\n    }\r\n  }\r\n\r\n  return static_cast<int64>(errorType.FORMAT_NOT_SUPPORT)\r\n}\r\n","/*\r\n * libmedia dts util\r\n *\r\n * 版权所有 (C) 2024 赵高兴\r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n * 此文件是 libmedia 的一部分\r\n * This file is part of libmedia.\r\n * \r\n * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1\r\n * 或任何其更新的版本条款重新分发或修改它\r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证\r\n * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。\r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport BitReader from 'common/io/BitReader'\r\nimport { Uint8ArrayInterface } from 'common/io/interface'\r\nimport align from 'common/math/align'\r\n\r\nconst DTSChannelTab = [1, 2, 2, 2, 2, 3, 3, 4, 4, 5, 6, 6, 6, 7, 8, 8]\r\n\r\nconst DTSSampleRateTab = [0, 8000, 16000, 32000, 0, 0, 11025, 22050, 44100, 0, 0, 12000, 24000, 48000, 96000, 192000]\r\n\r\nconst DTSBitrateTab = [32000, 56000, 64000, 96000, 112000, 128000, 192000, 224000, 256000, 320000, 384000, 448000,\r\n  512000, 576000, 640000, 768000, 960000, 1024000, 1152000, 1280000, 1344000, 1408000, 1411200, 1472000, 1536000,\r\n  1920000, 2048000, 3072000, 3840000, 0, 0, 0\r\n]\r\n\r\nexport const DTS_PCMBLOCK_SAMPLES = 32\r\n\r\nexport interface DTSHeaderInfo {\r\n  syncWord: uint32\r\n  frameType: int32\r\n  deficitSamples: int32\r\n  crcFlag: int32\r\n  sampleBlock: int32\r\n  frameSize: int32\r\n  channelIndex: int32\r\n  sampleRateIndex: int32\r\n  bitrateIndex: int32\r\n\r\n  channels: int32\r\n  sampleRate: int32\r\n  bitrate: int32\r\n}\r\n\r\nexport function parseHeader(buf: Uint8ArrayInterface) {\r\n  const bitReader = new BitReader(buf.length)\r\n  bitReader.appendBuffer(buf)\r\n\r\n  const info: DTSHeaderInfo = {\r\n    syncWord: 0,\r\n    frameType: 0,\r\n    deficitSamples: 0,\r\n    crcFlag: 0,\r\n    sampleBlock: 0,\r\n    frameSize: 0,\r\n    channelIndex: 0,\r\n    sampleRateIndex: 0,\r\n    bitrateIndex: 0,\r\n\r\n    channels: 0,\r\n    sampleRate: 0,\r\n    bitrate: 0\r\n  }\r\n\r\n  info.syncWord = bitReader.readU(32)\r\n\r\n  if (info.syncWord !== 0x7ffe8001 && info.syncWord !== 0xfe7f0180) {\r\n    return -1\r\n  }\r\n\r\n  info.frameType = bitReader.readU1()\r\n  info.deficitSamples = bitReader.readU(5) + 1\r\n  info.crcFlag = bitReader.readU1()\r\n  info.sampleBlock = bitReader.readU(7) + 1\r\n  info.frameSize = align(bitReader.readU(14) + 1, 4)\r\n  info.channelIndex = bitReader.readU(6)\r\n  info.sampleRateIndex = bitReader.readU(4)\r\n  info.bitrateIndex = bitReader.readU(5)\r\n\r\n  info.channels = DTSChannelTab[info.channelIndex]\r\n  info.sampleRate = DTSSampleRateTab[info.sampleRateIndex]\r\n  info.bitrate = DTSBitrateTab[info.bitrateIndex]\r\n\r\n  return info\r\n}\r\n","/*\r\n * libmedia opus util\r\n *\r\n * 版权所有 (C) 2024 赵高兴\r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n * 此文件是 libmedia 的一部分\r\n * This file is part of libmedia.\r\n * \r\n * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1\r\n * 或任何其更新的版本条款重新分发或修改它\r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证\r\n * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。\r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport { AVPacketSideDataType } from '../codec'\r\nimport AVStream from '../AVStream'\r\nimport AVCodecParameters from '../struct/avcodecparameters'\r\nimport BufferReader from 'common/io/BufferReader'\r\nimport BufferWriter from 'common/io/BufferWriter'\r\nimport { avRescaleQ } from '../util/rational'\r\nimport { Uint8ArrayInterface } from 'common/io/interface'\r\n\r\nexport const durations = [\r\n  /* Silk NB */\r\n  480, 960, 1920, 2880,\r\n  /* Silk MB */\r\n  480, 960, 1920, 2880,\r\n  /* Silk WB */\r\n  480, 960, 1920, 2880,\r\n  /* Hybrid SWB */\r\n  480, 960,\r\n  /* Hybrid FB */\r\n  480, 960,\r\n  /* CELT NB */\r\n  120, 240, 480, 960,\r\n  /* CELT NB */\r\n  120, 240, 480, 960,\r\n  /* CELT NB */\r\n  120, 240, 480, 960,\r\n  /* CELT NB */\r\n  120, 240, 480, 960\r\n]\r\n\r\n\r\nexport function getBufferSamples(buffer: Uint8Array) {\r\n  let toc = 0, frameDuration = 0, nframes = 0\r\n\r\n  if (buffer.length < 1) {\r\n    return 0\r\n  }\r\n\r\n  toc = buffer[0]\r\n\r\n  frameDuration = durations[toc >> 3]\r\n\r\n  switch (toc & 3) {\r\n    case 0:\r\n      nframes = 1\r\n      break\r\n    case 1:\r\n      nframes = 2\r\n      break\r\n    case 2:\r\n      nframes = 2\r\n      break\r\n    case 3:\r\n      if (buffer.length < 2) {\r\n        return 0\r\n      }\r\n      nframes = buffer[1] & 63\r\n      break\r\n  }\r\n  return nframes * frameDuration\r\n}\r\n\r\n/**\r\n * opus extradata\r\n * \r\n * - 8 bytes Magic Signature: OpusHead\r\n * - 1 bytes unsigned, 对应值 0x01 version\r\n * - 1 bytes unsigned, channels 它可能和编码声道数不一致， 它可能被修改成 packet-by-packet, 对应值 0x01\r\n * - 2 bytes unsigned, preSkip 这是要从开始播放时的解码器输出， 从页面的颗粒位置减去以计算其 PCM 样本位置。\r\n * - 4 bytes unsigned, sampleRate 原始输入采样率\r\n * - 2 bytes signed, outputGain 这是解码时要应用的增益， 20 * log10 缩放解码器输出以实现所需的播放音量\r\n * - 1 bytes unsigned, channelMappingFamily 指示输出渠道的顺序和语音含义。该八位位组的每个当前指定的值表示一个映射系列，它定义了一组允许的通道数，以及每个允许的通道数的通道名称的有序集合\r\n * - channelMappingTable 可选， 当 Channel Mapping Family 为 0 时被省略。\r\n *  - 1 bytes, streamCount, unsigned ogg packet 里面编码了多少路 stream\r\n *  - 1 bytes, coupledStreamCount, unsigned 标识有多少路流是双声声道，必须小于 streamCount\r\n *  - C bytes, C 为总输出声道数 coupledStreamCount + streamCount\r\n * \r\n */\r\nexport function parseAVCodecParameters(stream: AVStream, extradata?: Uint8ArrayInterface) {\r\n  if (!extradata && stream.sideData[AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA]) {\r\n    extradata = stream.sideData[AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA]\r\n  }\r\n  if (extradata && extradata.length >= 19) {\r\n    const reader = new BufferReader(extradata, false)\r\n    reader.skip(9)\r\n    stream.codecpar.chLayout.nbChannels = reader.readUint8()\r\n    stream.codecpar.initialPadding = reader.readUint16()\r\n    stream.codecpar.sampleRate = reader.readUint32()\r\n\r\n    stream.codecpar.seekPreroll = Number(avRescaleQ(\r\n      80n,\r\n      {\r\n        den: 1000,\r\n        num: 1\r\n      },\r\n      {\r\n        den: 48000,\r\n        num: 1\r\n      }\r\n    ))\r\n  }\r\n}\r\n\r\nexport function avCodecParameters2Extradata(codecpar: AVCodecParameters) {\r\n  const extradata = new Uint8Array(19)\r\n\r\n  const writer = new BufferWriter(extradata, false)\r\n\r\n  writer.writeString('OpusHead')\r\n  writer.writeUint8(0x01)\r\n  writer.writeUint8(codecpar.chLayout.nbChannels)\r\n  writer.writeUint16(codecpar.initialPadding)\r\n  writer.writeUint32(codecpar.sampleRate)\r\n\r\n  return extradata\r\n}\r\n"],"names":[],"sourceRoot":""}