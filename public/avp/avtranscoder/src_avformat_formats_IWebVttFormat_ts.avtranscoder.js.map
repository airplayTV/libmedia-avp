{"version":3,"file":"src_avformat_formats_IWebVttFormat_ts.avtranscoder.js","mappings":"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","sources":["webpack://AVTranscoder/./src/avformat/formats/IFormat.ts","webpack://AVTranscoder/./src/avformat/formats/IWebVttFormat.ts","webpack://AVTranscoder/./src/common/util/time.ts"],"sourcesContent":["/*\r\n * libmedia abstract format decoder\r\n *\r\n * 版权所有 (C) 2024 赵高兴\r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n * 此文件是 libmedia 的一部分\r\n * This file is part of libmedia.\r\n * \r\n * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1\r\n * 或任何其更新的版本条款重新分发或修改它\r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证\r\n * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。\r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport Stream from 'avutil/AVStream'\r\nimport { AVIFormatContext } from '../AVFormatContext'\r\nimport AVPacket from 'avutil/struct/avpacket'\r\nimport { AVFormat } from 'avutil/avformat'\r\n\r\nexport default abstract class IFormat {\r\n\r\n  public type: AVFormat = AVFormat.UNKNOWN\r\n\r\n  public onStreamAdd: (stream: Stream) => void\r\n\r\n  public abstract init(formatContext: AVIFormatContext): void\r\n\r\n  public async destroy(formatContext: AVIFormatContext): Promise<void> {}\r\n\r\n  public abstract getAnalyzeStreamsCount(): number\r\n  public abstract readHeader(formatContext: AVIFormatContext): Promise<number>\r\n  public abstract readAVPacket(formatContext: AVIFormatContext, avpacket: pointer<AVPacket>): Promise<number>\r\n\r\n  /**\r\n   * seek\r\n   * \r\n   * @param context \r\n   * @param stream \r\n   * @param timestamp 毫秒时间戳\r\n   * @param flags \r\n   * \r\n   * @returns 返回 seek 之前的下一个 avpacket pos（若不知道返回 0n 方便之后可以再 seek 回来）返回负数表示 seek 失败\r\n   */\r\n  public abstract seek(\r\n    formatContext: AVIFormatContext,\r\n    stream: Stream,\r\n    timestamp: int64,\r\n    flags: int32\r\n  ): Promise<int64>\r\n}\r\n","/*\r\n * libmedia vtt decoder\r\n *\r\n * 版权所有 (C) 2024 赵高兴\r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n * 此文件是 libmedia 的一部分\r\n * This file is part of libmedia.\r\n * \r\n * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1\r\n * 或任何其更新的版本条款重新分发或修改它\r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证\r\n * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。\r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport AVStream from 'avutil/AVStream'\r\nimport { AVIFormatContext } from '../AVFormatContext'\r\nimport AVPacket from 'avutil/struct/avpacket'\r\nimport { AVCodecID, AVMediaType, AVPacketSideDataType } from 'avutil/codec'\r\nimport * as logger from 'common/util/logger'\r\nimport * as errorType from 'avutil/error'\r\nimport IFormat from './IFormat'\r\nimport { AVFormat, AVSeekFlags, IOFlags } from 'avutil/avformat'\r\nimport { memcpyFromUint8Array } from 'cheap/std/memory'\r\nimport { avMalloc } from 'avutil/util/mem'\r\nimport { addAVPacketData, addAVPacketSideData } from 'avutil/util/avpacket'\r\nimport { IOError } from 'common/io/error'\r\nimport * as array from 'common/util/array'\r\nimport * as text from 'common/util/text'\r\nimport { hhColonDDColonSSDotMill2Int64 } from 'common/util/time'\r\nimport { AV_MILLI_TIME_BASE_Q } from 'avutil/constant'\r\nimport { AVStreamMetadataKey } from 'avutil/AVStream'\r\nimport { avRescaleQ } from 'avutil/util/rational'\r\n\r\nexport default class IWebVttFormat extends IFormat {\r\n\r\n  public type: AVFormat = AVFormat.WEBVTT\r\n\r\n  private queue: {\r\n    identifier?: string\r\n    options?: string\r\n    startTs: int64\r\n    endTs: int64\r\n    context: string\r\n    pos: int64\r\n  }[]\r\n  private index: int32\r\n  private baseTs: int64\r\n\r\n  constructor() {\r\n    super()\r\n  }\r\n\r\n  public init(formatContext: AVIFormatContext): void {\r\n    this.queue = []\r\n    this.baseTs = 0n\r\n  }\r\n\r\n  private async readChunk(formatContext: AVIFormatContext) {\r\n    let chunk = ''\r\n    const pos = formatContext.ioReader.getPos()\r\n    while (true) {\r\n      const line = await formatContext.ioReader.readLine()\r\n      if (line === '' || line === 'WEBVTT') {\r\n        break\r\n      }\r\n      chunk += line + '\\n'\r\n    }\r\n    return { chunk: chunk.trim(), pos }\r\n  }\r\n\r\n  private async readCue(formatContext: AVIFormatContext, styles: { style: string, pos: int64 }[]) {\r\n    while (true) {\r\n      const { chunk, pos } = await this.readChunk(formatContext)\r\n\r\n      if (chunk === '' || /^NOTE/.test(chunk) || chunk === 'WEBVTT') {\r\n        continue\r\n      }\r\n\r\n      if (/^STYLE/.test(chunk)) {\r\n        styles.push({\r\n          style: chunk.replace(/STYLE[\\s|\\n]?/, ''),\r\n          pos\r\n        })\r\n        continue\r\n      }\r\n      if (/^X-TIMESTAMP-MAP/.test(chunk)) {\r\n        const value = chunk.split('=')[1]\r\n        const items = value.split(',')\r\n        let local = 0n\r\n        let ts = 0n\r\n        items.forEach((t) => {\r\n          const l = t.split(':')\r\n          if (l[0] === 'LOCAL') {\r\n            l.shift()\r\n            local = hhColonDDColonSSDotMill2Int64(l.join(':').trim())\r\n          }\r\n          else if (l[0] === 'MPEGTS') {\r\n            ts = BigInt(+l[1]) * 1000n / 90000n\r\n          }\r\n        })\r\n        this.baseTs = ts - local\r\n        continue\r\n      }\r\n\r\n      const lines = chunk.split('\\n')\r\n\r\n      let identifier: string\r\n      let options: string\r\n\r\n      // identifier\r\n      if (lines[0].indexOf('-->') === -1) {\r\n        identifier = lines.shift().trim()\r\n      }\r\n\r\n      let times = lines.shift().split('-->')\r\n      const startTs = hhColonDDColonSSDotMill2Int64(times.shift()) + this.baseTs\r\n\r\n      times = times.shift().trim().split(' ')\r\n\r\n      const endTs = hhColonDDColonSSDotMill2Int64(times.shift()) + this.baseTs\r\n\r\n      if (endTs <= startTs) {\r\n        continue\r\n      }\r\n\r\n      times = times.filter((t) => t !== '')\r\n\r\n      if (times.length) {\r\n        options = times.join(' ')\r\n      }\r\n\r\n      const context = lines.join('\\n').trim()\r\n\r\n      if (!context) {\r\n        continue\r\n      }\r\n      return {\r\n        identifier,\r\n        options,\r\n        context,\r\n        startTs,\r\n        endTs,\r\n        pos\r\n      }\r\n    }\r\n  }\r\n\r\n  public async readHeader(formatContext: AVIFormatContext): Promise<number> {\r\n\r\n    const bom = await formatContext.ioReader.peekBuffer(3)\r\n\r\n    if (bom[0] === 0xef && bom[1] === 0xbb && bom[2] === 0xbf) {\r\n      await formatContext.ioReader.skip(3)\r\n    }\r\n\r\n    const signature = await formatContext.ioReader.peekString(6)\r\n    if (signature !== 'WEBVTT') {\r\n      logger.error('the file format is not vtt')\r\n      return errorType.DATA_INVALID\r\n    }\r\n\r\n    const stream = formatContext.createStream()\r\n    stream.codecpar.codecId = AVCodecID.AV_CODEC_ID_WEBVTT\r\n    stream.codecpar.codecType = AVMediaType.AVMEDIA_TYPE_SUBTITLE\r\n    stream.timeBase.den = 1000\r\n    stream.timeBase.num = 1\r\n\r\n    const header = await formatContext.ioReader.readLine()\r\n    if (header.indexOf('-') > 0) {\r\n      stream.metadata[AVStreamMetadataKey.TITLE] = header.split('-').pop().trim()\r\n    }\r\n\r\n    this.index = 0\r\n\r\n    const styles: { style: string, pos: int64 }[] = []\r\n\r\n    let lastStartTs = 0n\r\n\r\n    try {\r\n      while (true) {\r\n        const cue = await this.readCue(formatContext, styles)\r\n        stream.nbFrames++\r\n        stream.duration = cue.endTs\r\n\r\n        if (cue.startTs >= lastStartTs) {\r\n          this.queue.push(cue)\r\n          lastStartTs = cue.startTs\r\n        }\r\n        else {\r\n          array.sortInsert(\r\n            this.queue,\r\n            cue,\r\n            (a) => {\r\n              if (a.startTs < cue.startTs) {\r\n                return 1\r\n              }\r\n              else {\r\n                return -1\r\n              }\r\n            }\r\n          )\r\n        }\r\n        if (formatContext.ioReader.flags & IOFlags.SLICE) {\r\n          break\r\n        }\r\n      }\r\n    }\r\n    catch (error) {}\r\n    stream.metadata[AVStreamMetadataKey.STYLES] = styles\r\n    return 0\r\n  }\r\n\r\n  public async readAVPacket(formatContext: AVIFormatContext, avpacket: pointer<AVPacket>): Promise<number> {\r\n\r\n    const stream = formatContext.streams.find((stream) => {\r\n      return stream.codecpar.codecType === AVMediaType.AVMEDIA_TYPE_SUBTITLE\r\n    })\r\n\r\n    if (formatContext.ioReader.flags & IOFlags.SLICE) {\r\n      if (this.index >= this.queue.length) {\r\n        try {\r\n          const cue = await this.readCue(formatContext, stream.metadata[AVStreamMetadataKey.STYLES])\r\n          if (this.queue.length) {\r\n            const last = this.queue[this.queue.length - 1]\r\n            // hls 的 字幕可能会重复\r\n            if (last.startTs === cue.startTs\r\n              && last.endTs === cue.endTs\r\n              && last.context === cue.context\r\n            ) {\r\n              return this.readAVPacket(formatContext, avpacket)\r\n            }\r\n          }\r\n          this.queue.push(cue)\r\n          stream.nbFrames++\r\n          stream.duration = cue.endTs\r\n        }\r\n        catch (error) {\r\n          if (formatContext.ioReader.error !== IOError.END\r\n            && formatContext.ioReader.error !== IOError.ABORT\r\n          ) {\r\n            logger.error(`read cue error, ${error}`)\r\n            return errorType.DATA_INVALID\r\n          }\r\n          return formatContext.ioReader.error\r\n        }\r\n      }\r\n    }\r\n    else {\r\n      if (!this.queue.length) {\r\n        return errorType.DATA_INVALID\r\n      }\r\n      if (this.index >= this.queue.length) {\r\n        return IOError.END\r\n      }\r\n    }\r\n\r\n    const cue = this.queue[this.index++]\r\n\r\n    avpacket.streamIndex = stream.index\r\n    avpacket.timeBase.den = stream.timeBase.den\r\n    avpacket.timeBase.num = stream.timeBase.num\r\n\r\n    avpacket.dts = avpacket.pts = cue.startTs\r\n    avpacket.duration = cue.endTs - cue.startTs\r\n\r\n    if (cue.identifier) {\r\n      const buffer = text.encode(cue.identifier)\r\n      const data = avMalloc(buffer.length)\r\n      memcpyFromUint8Array(data, buffer.length, buffer)\r\n      addAVPacketSideData(avpacket, AVPacketSideDataType.AV_PKT_DATA_WEBVTT_IDENTIFIER, data, buffer.length)\r\n    }\r\n    if (cue.options) {\r\n      const buffer = text.encode(cue.options)\r\n      const data = avMalloc(buffer.length)\r\n      memcpyFromUint8Array(data, buffer.length, buffer)\r\n      addAVPacketSideData(avpacket, AVPacketSideDataType.AV_PKT_DATA_WEBVTT_SETTINGS, data, buffer.length)\r\n    }\r\n    const buffer = text.encode(cue.context)\r\n    const data: pointer<uint8> = avMalloc(buffer.length)\r\n    memcpyFromUint8Array(data, buffer.length, buffer)\r\n    addAVPacketData(avpacket, data, buffer.length)\r\n\r\n    return 0\r\n  }\r\n\r\n  public async seek(formatContext: AVIFormatContext, stream: AVStream, timestamp: int64, flags: int32): Promise<int64> {\r\n    if (flags & AVSeekFlags.BYTE) {\r\n      return static_cast<int64>(errorType.FORMAT_NOT_SUPPORT)\r\n    }\r\n    if (flags & AVSeekFlags.TIMESTAMP && (formatContext.ioReader.flags & IOFlags.SLICE)) {\r\n      const seekTime = avRescaleQ(timestamp, stream.timeBase, AV_MILLI_TIME_BASE_Q)\r\n      await formatContext.ioReader.seek(seekTime, true)\r\n      this.queue.length = 0\r\n      this.index = 0\r\n      return 0n\r\n    }\r\n    if (timestamp <= 0n) {\r\n      this.index = 0\r\n      return 0n\r\n    }\r\n    const index = array.binarySearch(this.queue, (item) => {\r\n      if (item.startTs > timestamp) {\r\n        return -1\r\n      }\r\n      return 1\r\n    })\r\n    if (index >= 0) {\r\n      logger.debug(`seek in cues, found index: ${index}, pts: ${this.queue[index].startTs}, pos: ${this.queue[index].pos}`)\r\n      this.index = Math.max(index - 1, 0)\r\n      while (this.index > 0) {\r\n        if (this.queue[this.index - 1].startTs === this.queue[this.index].startTs\r\n          || this.queue[this.index - 1].endTs > timestamp\r\n        ) {\r\n          this.index--\r\n        }\r\n        else {\r\n          break\r\n        }\r\n      }\r\n      return 0n\r\n    }\r\n    return static_cast<int64>(errorType.DATA_INVALID)\r\n  }\r\n\r\n  public getAnalyzeStreamsCount(): number {\r\n    return 1\r\n  }\r\n}\r\n","\r\nexport function hhColonDDColonSSDotMill2Int64(time: string) {\r\n  if (!time) {\r\n    return -1n\r\n  }\r\n\r\n  time = time.trim()\r\n\r\n  let list = time.split(':')\r\n\r\n  let ts = 0n\r\n\r\n  if (list.length === 3) {\r\n    ts += BigInt(+(list.shift().trim())) * 3600000n\r\n  }\r\n  ts += BigInt(+(list.shift().trim())) * 60000n\r\n\r\n  list = list.shift().trim().split('.')\r\n  ts += BigInt(+(list.shift().trim())) * 1000n\r\n  if (list.length) {\r\n    ts += BigInt(+(list.shift().trim()))\r\n  }\r\n\r\n  return ts\r\n}\r\n\r\nexport function hhColonDDColonSSCommaMill2Int64(time: string) {\r\n  if (!time) {\r\n    return -1n\r\n  }\r\n\r\n  time = time.trim()\r\n\r\n  let list = time.split(':')\r\n\r\n  let ts = 0n\r\n\r\n  if (list.length === 3) {\r\n    ts += BigInt(+(list.shift().trim())) * 3600000n\r\n  }\r\n  ts += BigInt(+(list.shift().trim())) * 60000n\r\n\r\n  list = list.shift().trim().split(',')\r\n  ts += BigInt(+(list.shift().trim())) * 1000n\r\n  if (list.length) {\r\n    ts += BigInt(+(list.shift().trim()))\r\n  }\r\n\r\n  return ts\r\n}\r\n"],"names":[],"sourceRoot":""}