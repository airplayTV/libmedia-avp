{"version":3,"file":"src_avformat_formats_IIvfFormat_ts.avtranscoder.js","mappings":"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","sources":["webpack://AVTranscoder/./src/avformat/formats/IFormat.ts","webpack://AVTranscoder/./src/avformat/formats/IIvfFormat.ts"],"sourcesContent":["/*\r\n * libmedia abstract format decoder\r\n *\r\n * 版权所有 (C) 2024 赵高兴\r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n * 此文件是 libmedia 的一部分\r\n * This file is part of libmedia.\r\n * \r\n * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1\r\n * 或任何其更新的版本条款重新分发或修改它\r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证\r\n * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。\r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport Stream from 'avutil/AVStream'\r\nimport { AVIFormatContext } from '../AVFormatContext'\r\nimport AVPacket from 'avutil/struct/avpacket'\r\nimport { AVFormat } from 'avutil/avformat'\r\n\r\nexport default abstract class IFormat {\r\n\r\n  public type: AVFormat = AVFormat.UNKNOWN\r\n\r\n  public onStreamAdd: (stream: Stream) => void\r\n\r\n  public abstract init(formatContext: AVIFormatContext): void\r\n\r\n  public async destroy(formatContext: AVIFormatContext): Promise<void> {}\r\n\r\n  public abstract getAnalyzeStreamsCount(): number\r\n  public abstract readHeader(formatContext: AVIFormatContext): Promise<number>\r\n  public abstract readAVPacket(formatContext: AVIFormatContext, avpacket: pointer<AVPacket>): Promise<number>\r\n\r\n  /**\r\n   * seek\r\n   * \r\n   * @param context \r\n   * @param stream \r\n   * @param timestamp 毫秒时间戳\r\n   * @param flags \r\n   * \r\n   * @returns 返回 seek 之前的下一个 avpacket pos（若不知道返回 0n 方便之后可以再 seek 回来）返回负数表示 seek 失败\r\n   */\r\n  public abstract seek(\r\n    formatContext: AVIFormatContext,\r\n    stream: Stream,\r\n    timestamp: int64,\r\n    flags: int32\r\n  ): Promise<int64>\r\n}\r\n","/*\r\n * libmedia lvf decoder\r\n *\r\n * 版权所有 (C) 2024 赵高兴\r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n * 此文件是 libmedia 的一部分\r\n * This file is part of libmedia.\r\n * \r\n * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1\r\n * 或任何其更新的版本条款重新分发或修改它\r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证\r\n * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。\r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport { AVIFormatContext } from '../AVFormatContext'\r\nimport AVPacket from 'avutil/struct/avpacket'\r\nimport { AVCodecID, AVMediaType } from 'avutil/codec'\r\nimport * as logger from 'common/util/logger'\r\nimport { IOError } from 'common/io/error'\r\nimport * as errorType from 'avutil/error'\r\nimport IFormat from './IFormat'\r\nimport { AVFormat, AVSeekFlags } from 'avutil/avformat'\r\nimport { mapSafeUint8Array } from 'cheap/std/memory'\r\nimport { avMalloc } from 'avutil/util/mem'\r\nimport { addAVPacketData } from 'avutil/util/avpacket'\r\nimport AVStream from 'avutil/AVStream'\r\nimport { NOPTS_VALUE_BIGINT } from 'avutil/constant'\r\n\r\nexport const enum IVFCodec {\r\n  VP8 = 'VP80',\r\n  VP9 = 'VP90'\r\n}\r\n\r\nconst IVFCodec2CodecId = {\r\n  [IVFCodec.VP8]: AVCodecID.AV_CODEC_ID_VP8,\r\n  [IVFCodec.VP9]: AVCodecID.AV_CODEC_ID_VP9,\r\n}\r\n\r\nexport class IVFHeader {\r\n  // version (should be 0)\r\n  public version: number\r\n  // length of header in bytes\r\n  public length: number\r\n  // FourCC (e.g., 'VP80')\r\n  public codec: IVFCodec\r\n  // width in pixels\r\n  public width: number\r\n  // height in pixels\r\n  public height: number\r\n  // denominator\r\n  public denominator: number\r\n  // numerator\r\n  public numerator: number\r\n  // number of frames in file\r\n  public framesCount: number\r\n\r\n  constructor() {\r\n    this.version = 0\r\n    this.length = 32\r\n    this.codec = IVFCodec.VP8\r\n    this.width = 0\r\n    this.height = 0\r\n    this.framesCount = 0\r\n    this.denominator = 1\r\n    this.numerator = 0\r\n  }\r\n}\r\n\r\nexport default class IIVFFormat extends IFormat {\r\n\r\n  public type: AVFormat = AVFormat.IVF\r\n\r\n  public header: IVFHeader\r\n\r\n  constructor() {\r\n    super()\r\n\r\n    this.header = new IVFHeader()\r\n  }\r\n\r\n  public init(formatContext: AVIFormatContext): void {\r\n\r\n    if (formatContext.ioReader) {\r\n      formatContext.ioReader.setEndian(false)\r\n    }\r\n  }\r\n\r\n  public async readHeader(formatContext: AVIFormatContext): Promise<number> {\r\n    try {\r\n\r\n      const signature = await formatContext.ioReader.readString(4)\r\n      if (signature !== 'DKIF') {\r\n        logger.error('the file format is not ivf')\r\n        return errorType.DATA_INVALID\r\n      }\r\n\r\n      this.header.version = await formatContext.ioReader.readUint16()\r\n      await formatContext.ioReader.skip(2)\r\n      this.header.codec = await formatContext.ioReader.readString(4) as IVFCodec\r\n      this.header.width = await formatContext.ioReader.readUint16()\r\n      this.header.height = await formatContext.ioReader.readUint16()\r\n      this.header.denominator = await formatContext.ioReader.readUint32()\r\n      this.header.numerator = await formatContext.ioReader.readUint32()\r\n      this.header.framesCount = await formatContext.ioReader.readUint32()\r\n\r\n      // unused\r\n      await formatContext.ioReader.skip(4)\r\n\r\n      const stream = formatContext.createStream()\r\n      stream.codecpar.codecType = AVMediaType.AVMEDIA_TYPE_VIDEO\r\n      stream.codecpar.codecId = IVFCodec2CodecId[this.header.codec]\r\n      stream.timeBase.den = this.header.denominator\r\n      stream.timeBase.num = this.header.numerator\r\n      stream.codecpar.width = this.header.width\r\n      stream.codecpar.height = this.header.height\r\n      stream.nbFrames = static_cast<int64>(this.header.framesCount)\r\n\r\n      if (this.onStreamAdd) {\r\n        this.onStreamAdd(stream)\r\n      }\r\n\r\n      return 0\r\n    }\r\n    catch (error) {\r\n      logger.error(error.message)\r\n      return formatContext.ioReader.error\r\n    }\r\n  }\r\n\r\n  public async readAVPacket(formatContext: AVIFormatContext, avpacket: pointer<AVPacket>): Promise<number> {\r\n    try {\r\n\r\n      const stream = formatContext.getStreamByMediaType(AVMediaType.AVMEDIA_TYPE_VIDEO)\r\n\r\n      if (stream) {\r\n        const pos = formatContext.ioReader.getPos()\r\n        const size = await formatContext.ioReader.readUint32()\r\n        const pts = await formatContext.ioReader.readUint64()\r\n\r\n        const data: pointer<uint8> = avMalloc(size)\r\n        addAVPacketData(avpacket, data, size)\r\n        await formatContext.ioReader.readBuffer(size, mapSafeUint8Array(data, size))\r\n\r\n        avpacket.pos = pos\r\n        avpacket.pts = avpacket.dts = pts\r\n        avpacket.timeBase.den = this.header.denominator\r\n        avpacket.timeBase.num = this.header.numerator\r\n        avpacket.streamIndex = stream.index\r\n\r\n        if (stream.startTime === NOPTS_VALUE_BIGINT) {\r\n          stream.startTime = avpacket.pts || avpacket.dts\r\n        }\r\n      }\r\n      else {\r\n        return errorType.DATA_INVALID\r\n      }\r\n\r\n      return 0\r\n    }\r\n    catch (error) {\r\n      if (formatContext.ioReader.error !== IOError.END\r\n        && formatContext.ioReader.error !== IOError.ABORT\r\n      ) {\r\n        logger.error(`read packet error, ${error}`)\r\n        return errorType.DATA_INVALID\r\n      }\r\n      return formatContext.ioReader.error\r\n    }\r\n  }\r\n\r\n  public async seek(formatContext: AVIFormatContext, stream: AVStream, timestamp: int64, flags: int32): Promise<int64> {\r\n\r\n    const now = formatContext.ioReader.getPos()\r\n\r\n    if (flags & AVSeekFlags.BYTE) {\r\n      await formatContext.ioReader.seek(timestamp)\r\n      return now\r\n    }\r\n\r\n    return static_cast<int64>(errorType.FORMAT_NOT_SUPPORT)\r\n  }\r\n\r\n  public getAnalyzeStreamsCount(): number {\r\n    return 1\r\n  }\r\n\r\n}\r\n"],"names":[],"sourceRoot":""}