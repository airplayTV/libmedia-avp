{"version":3,"file":"src_avformat_formats_IFormat_ts-src_avformat_formats_riff_iriff_ts.avtranscoder.js","mappings":"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","sources":["webpack://AVTranscoder/./src/avformat/formats/IFormat.ts","webpack://AVTranscoder/./src/avformat/formats/riff/iriff.ts"],"sourcesContent":["/*\r\n * libmedia abstract format decoder\r\n *\r\n * 版权所有 (C) 2024 赵高兴\r\n * Copyright (C) 2024 Gaoxing Zhao\r\n *\r\n * 此文件是 libmedia 的一部分\r\n * This file is part of libmedia.\r\n * \r\n * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1\r\n * 或任何其更新的版本条款重新分发或修改它\r\n * libmedia is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation; either\r\n * version 3.1 of the License, or (at your option) any later version.\r\n * \r\n * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证\r\n * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。\r\n * libmedia is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n */\r\n\r\nimport Stream from 'avutil/AVStream'\r\nimport { AVIFormatContext } from '../AVFormatContext'\r\nimport AVPacket from 'avutil/struct/avpacket'\r\nimport { AVFormat } from 'avutil/avformat'\r\n\r\nexport default abstract class IFormat {\r\n\r\n  public type: AVFormat = AVFormat.UNKNOWN\r\n\r\n  public onStreamAdd: (stream: Stream) => void\r\n\r\n  public abstract init(formatContext: AVIFormatContext): void\r\n\r\n  public async destroy(formatContext: AVIFormatContext): Promise<void> {}\r\n\r\n  public abstract getAnalyzeStreamsCount(): number\r\n  public abstract readHeader(formatContext: AVIFormatContext): Promise<number>\r\n  public abstract readAVPacket(formatContext: AVIFormatContext, avpacket: pointer<AVPacket>): Promise<number>\r\n\r\n  /**\r\n   * seek\r\n   * \r\n   * @param context \r\n   * @param stream \r\n   * @param timestamp 毫秒时间戳\r\n   * @param flags \r\n   * \r\n   * @returns 返回 seek 之前的下一个 avpacket pos（若不知道返回 0n 方便之后可以再 seek 回来）返回负数表示 seek 失败\r\n   */\r\n  public abstract seek(\r\n    formatContext: AVIFormatContext,\r\n    stream: Stream,\r\n    timestamp: int64,\r\n    flags: int32\r\n  ): Promise<int64>\r\n}\r\n","import AVCodecParameters from 'avutil/struct/avcodecparameters'\r\nimport IOReader from 'common/io/IOReader'\r\nimport * as logger from 'common/util/logger'\r\nimport * as errorType from 'avutil/error'\r\nimport { AVCodecID, AVMediaType } from 'avutil/codec'\r\nimport { AMBISONIC_BASE_GUID, BROKEN_BASE_GUID, codecBmpGuid, MEDIASUBTYPE_BASE_GUID, WavTag2CodecId } from './riff'\r\nimport { getPcmCodecId } from 'avutil/util/pcm'\r\nimport { avFree, avMalloc } from 'avutil/util/mem'\r\nimport { mapSafeUint8Array, mapUint8Array } from 'cheap/std/memory'\r\nimport * as intread from 'avutil/util/intread'\r\nimport { AVChannelOrder } from 'avutil/audiosamplefmt'\r\nimport { Data } from 'common/types/type'\r\nimport AVStream from 'avutil/AVStream'\r\nimport { setChannelLayoutFromMask, unInitChannelLayout } from 'avutil/util/channel'\r\n\r\nexport function getWavCodecId(tag: int32, bitsPerCodedSample: int32) {\r\n  let codecId: AVCodecID = WavTag2CodecId[tag]\r\n\r\n  if (!codecId) {\r\n    return AVCodecID.AV_CODEC_ID_NONE\r\n  }\r\n\r\n  if (codecId === AVCodecID.AV_CODEC_ID_PCM_U8) {\r\n    codecId = getPcmCodecId(bitsPerCodedSample, false, false, ~1)\r\n  }\r\n  else if (codecId === AVCodecID.AV_CODEC_ID_PCM_F32LE) {\r\n    codecId = getPcmCodecId(bitsPerCodedSample, true, false, 0)\r\n  }\r\n\r\n  if (codecId === AVCodecID.AV_CODEC_ID_ADPCM_IMA_WAV && bitsPerCodedSample === 8) {\r\n    codecId = AVCodecID.AV_CODEC_ID_ADPCM_ZORK\r\n  }\r\n\r\n  return codecId\r\n}\r\n\r\nexport function getGuidCodecId(guid: string) {\r\n  let codecId: AVCodecID = codecBmpGuid[guid.toLocaleUpperCase()]\r\n\r\n  if (!codecId) {\r\n    return AVCodecID.AV_CODEC_ID_NONE\r\n  }\r\n\r\n  return codecId\r\n}\r\n\r\nexport async function readFormatTag(ioReader: IOReader, codecpar: pointer<AVCodecParameters>, size: int32) {\r\n  if (size < 14) {\r\n    logger.error('wav format size < 14')\r\n    return errorType.DATA_INVALID\r\n  }\r\n\r\n  codecpar.codecType = AVMediaType.AVMEDIA_TYPE_AUDIO\r\n\r\n  const audioFormat = await ioReader.readUint16()\r\n  let channels = await ioReader.readUint16()\r\n  const sampleRate = await ioReader.readUint32()\r\n  let bitrate = await ioReader.readUint32() * 8\r\n  const blockAlgin = await ioReader.readUint16()\r\n\r\n  codecpar.sampleRate = sampleRate\r\n  codecpar.blockAlign = blockAlgin\r\n\r\n  if (size === 14) {\r\n    codecpar.bitsPerCodedSample = 8\r\n  }\r\n  else {\r\n    codecpar.bitsPerCodedSample = await ioReader.readUint16()\r\n  }\r\n\r\n  if (audioFormat === 0xfffe) {\r\n    codecpar.codecTag = 0\r\n  }\r\n  else {\r\n    codecpar.codecTag = audioFormat\r\n    codecpar.codecId = getWavCodecId(audioFormat, codecpar.bitsPerCodedSample)\r\n  }\r\n\r\n  if (size >= 18 && audioFormat !== 0x0165) {\r\n    let cbSize = await ioReader.readUint16()\r\n    size -= 18\r\n\r\n    cbSize = Math.min(size, cbSize)\r\n\r\n    if (cbSize >= 22 && audioFormat === 0xfffe) {\r\n      // TODO parse wave format ex\r\n      await ioReader.skip(22)\r\n      cbSize -= 22\r\n      size   -= 22\r\n    }\r\n\r\n    if (cbSize > 0) {\r\n      codecpar.extradata = avMalloc(cbSize)\r\n      codecpar.extradataSize = cbSize\r\n      await ioReader.readBuffer(cbSize, mapSafeUint8Array(codecpar.extradata, cbSize))\r\n\r\n      size -= cbSize\r\n    }\r\n\r\n    if (size > 0) {\r\n      await ioReader.skip(size)\r\n    }\r\n  }\r\n  else if (audioFormat === 0x0165 && size >= 32) {\r\n    size -= 4\r\n\r\n    codecpar.extradata = avMalloc(reinterpret_cast<size>(size))\r\n    codecpar.extradataSize = size\r\n    await ioReader.readBuffer(size, mapSafeUint8Array(codecpar.extradata, reinterpret_cast<size>(size)))\r\n\r\n    const streams = intread.rl16(codecpar.extradata + 4)\r\n    codecpar.sampleRate = intread.rl32(codecpar.extradata + 12)\r\n\r\n    channels = 0\r\n    bitrate = 0\r\n\r\n    if (size < 8 + streams * 20) {\r\n      return errorType.DATA_INVALID\r\n    }\r\n\r\n    for (let i = 0; i < streams; i++) {\r\n      channels += codecpar.extradata[8 + i * 20 + 17]\r\n    }\r\n  }\r\n\r\n  codecpar.bitrate = BigInt(bitrate)\r\n\r\n  if (codecpar.sampleRate < 0) {\r\n    logger.error(`Invalid sample rate: ${codecpar.sampleRate}`)\r\n    return errorType.DATA_INVALID\r\n  }\r\n\r\n  if (codecpar.codecId === AVCodecID.AV_CODEC_ID_AAC_LATM) {\r\n    channels = 0\r\n    codecpar.sampleRate = 0\r\n  }\r\n\r\n  if (codecpar.codecId == AVCodecID.AV_CODEC_ID_ADPCM_G726 && codecpar.sampleRate) {\r\n    codecpar.bitsPerCodedSample = static_cast<int32>(codecpar.bitrate) / codecpar.sampleRate\r\n  }\r\n  if (channels != codecpar.chLayout.nbChannels) {\r\n    codecpar.chLayout.order = AVChannelOrder.AV_CHANNEL_ORDER_UNSPEC\r\n    codecpar.chLayout.nbChannels = channels\r\n  }\r\n  return 0\r\n}\r\n\r\nexport async function readInfo(ioReader: IOReader, size: int64, metadata: Data) {\r\n  const end = ioReader.getPos() + size\r\n  while (ioReader.getPos() < end) {\r\n    const key = await ioReader.readString(4)\r\n    const size = await ioReader.readUint32()\r\n    const value = await ioReader.readString(size)\r\n    metadata[key] = value\r\n    if (size % 2) {\r\n      await ioReader.skip(1)\r\n    }\r\n  }\r\n}\r\n\r\nexport async function readBmpHeader(ioReader: IOReader, stream: AVStream) {\r\n  const esize = await ioReader.readUint32()\r\n  stream.codecpar.width = await ioReader.readUint32()\r\n  stream.codecpar.height = await ioReader.readUint32()\r\n  await ioReader.skip(2)\r\n  stream.codecpar.bitsPerCodedSample = await ioReader.readUint16()\r\n  stream.codecpar.codecTag = await ioReader.readUint32()\r\n  await ioReader.skip(20)\r\n  return esize\r\n}\r\n\r\nexport async function readWaveformatex(ioReader: IOReader, stream: AVStream) {\r\n  const bsp = await ioReader.readUint16()\r\n  if (bsp) {\r\n    stream.codecpar.bitsPerCodedSample = bsp\r\n  }\r\n  const mask: uint32 = await ioReader.readUint32()\r\n  setChannelLayoutFromMask(addressof(stream.codecpar.chLayout), static_cast<uint64>(mask))\r\n  const subFormat = (await ioReader.readHex(16)).toLocaleUpperCase()\r\n  if (subFormat.slice(4) === AMBISONIC_BASE_GUID\r\n    || subFormat.slice(4) === BROKEN_BASE_GUID\r\n    || subFormat.slice(4) === MEDIASUBTYPE_BASE_GUID\r\n  ) {\r\n    stream.codecpar.codecTag = await ioReader.readUint32()\r\n    stream.codecpar.codecId = getWavCodecId(reinterpret_cast<int32>(stream.codecpar.codecTag), stream.codecpar.bitsPerCodedSample)\r\n  }\r\n  else {\r\n    stream.codecpar.codecId = getGuidCodecId(subFormat)\r\n    if (!stream.codecpar.codecId) {\r\n      logger.warn(`unknown subformat: ${subFormat}`)\r\n    }\r\n  }\r\n}\r\n\r\nexport async function readWavHeader(ioReader: IOReader, stream: AVStream, size: int32) {\r\n  if (size < 14) {\r\n    logger.error('wav header size < 14')\r\n    return errorType.DATA_INVALID\r\n  }\r\n  unInitChannelLayout(addressof(stream.codecpar.chLayout))\r\n  let id: number\r\n  let channels: number\r\n  let bitrate: number\r\n\r\n  id = await ioReader.readUint16()\r\n  if (id !== 0x0165 || ioReader.isBigEndian()) {\r\n    channels = await ioReader.readUint16()\r\n    stream.codecpar.sampleRate = await ioReader.readUint32()\r\n    bitrate = (await ioReader.readUint32()) * 8\r\n    stream.codecpar.blockAlign = await ioReader.readUint16()\r\n  }\r\n\r\n  if (size === 14) {\r\n    stream.codecpar.bitsPerCodedSample = 8\r\n  }\r\n  else {\r\n    stream.codecpar.bitsPerCodedSample = await ioReader.readUint16()\r\n  }\r\n  if (id === 0xFFFE) {\r\n    stream.codecpar.codecTag = 0\r\n  }\r\n  else {\r\n    stream.codecpar.codecTag = id\r\n    stream.codecpar.codecId = getWavCodecId(id, stream.codecpar.bitsPerCodedSample)\r\n  }\r\n  if (size >= 18 && id != 0x0165) {\r\n    let cbSize = await ioReader.readUint16()\r\n    if (ioReader.isBigEndian()) {\r\n      logger.error('WAVEFORMATEX support for RIFX files')\r\n      return errorType.DATA_INVALID\r\n    }\r\n    size  -= 18\r\n    cbSize = Math.min(cbSize, size)\r\n    if (cbSize >= 22 && id == 0xfffe) {\r\n      await readWaveformatex(ioReader, stream)\r\n      cbSize -= 22\r\n      size -= 22\r\n    }\r\n    if (cbSize > 0) {\r\n      if (stream.codecpar.extradata) {\r\n        avFree(stream.codecpar.extradata)\r\n      }\r\n      stream.codecpar.extradataSize = cbSize\r\n      stream.codecpar.extradata = avMalloc(reinterpret_cast<size>(cbSize as uint32))\r\n      await ioReader.readBuffer(cbSize, mapSafeUint8Array(stream.codecpar.extradata, reinterpret_cast<size>(cbSize as uint32)))\r\n      size -= cbSize\r\n    }\r\n    if (size > 0) {\r\n      await ioReader.skip(size)\r\n    }\r\n  }\r\n  else if (id == 0x0165 && size >= 32) {\r\n    size -= 4\r\n    if (stream.codecpar.extradata) {\r\n      avFree(stream.codecpar.extradata)\r\n    }\r\n    stream.codecpar.extradataSize = size\r\n    stream.codecpar.extradata = avMalloc(reinterpret_cast<size>(size))\r\n    await ioReader.readBuffer(size, mapSafeUint8Array(stream.codecpar.extradata, reinterpret_cast<size>(size)))\r\n    const nbStreams = intread.rl16(stream.codecpar.extradata + 4)\r\n    stream.codecpar.sampleRate = intread.rl32(stream.codecpar.extradata + 12)\r\n    if (size < 8 + nbStreams * 20) {\r\n      return errorType.DATA_INVALID\r\n    }\r\n    for (let i = 0; i < nbStreams; i++) {\r\n      channels += stream.codecpar.extradata[8 + i * 20 + 17]\r\n    }\r\n  }\r\n\r\n  stream.codecpar.bitrate = static_cast<int64>(bitrate as int32)\r\n  if (stream.codecpar.sampleRate < 0) {\r\n    logger.error(`Invalid sample rate ${stream.codecpar.sampleRate}`)\r\n    return errorType.DATA_INVALID\r\n  }\r\n  if (stream.codecpar.codecId === AVCodecID.AV_CODEC_ID_AAC_LATM) {\r\n    channels = 0\r\n    stream.codecpar.sampleRate = 0\r\n  }\r\n  if (stream.codecpar.codecId === AVCodecID.AV_CODEC_ID_ADPCM_G726 && stream.codecpar.sampleRate) {\r\n    stream.codecpar.bitsPerCodedSample = static_cast<double>(stream.codecpar.bitrate) / stream.codecpar.sampleRate\r\n  }\r\n  if (channels !== stream.codecpar.chLayout.nbChannels) {\r\n    unInitChannelLayout(addressof(stream.codecpar.chLayout))\r\n    stream.codecpar.chLayout.order = AVChannelOrder.AV_CHANNEL_ORDER_UNSPEC\r\n    stream.codecpar.chLayout.nbChannels = channels\r\n  }\r\n  return 0\r\n}\r\n"],"names":[],"sourceRoot":""}